#!/usr/bin/env bash
################################################################################
################################################################################
####### Migrate GitHub Deploy Keys #############################################
################################################################################
################################################################################

# LEGEND:
# This script is used by the gh command line to help migrate GitHub Deploy Keys
# of repositories. If no inpput file is provided, it will migrate the keys from
# all repositories in the source Organization to the destination Organization.
# If an input file is provided, it will migrate the keys from the repositories
# in the list to the source Organization.

#
# PREREQS:
# You need to have the following to run this script successfully:
# - GitHub Personal Access Token with a scope of "repos" and access to the organization(s) that will be updated.
# - Either the name of the organizations to be migrated, or a file containing the names of the repositories to be updated
# - jq installed on the machine running the query
#
# NOTES:
# Input file should be in the format:
# Repo_Name1
# Repo_Name2
# Repo_Name3
#

################################################################################
#### Function PrintUsage #######################################################
PrintUsage()
{
  cat <<EOM
Usage: gh migrate-deploy-keys [options]

Options:
    -h, --help                    : Show script help
    -d, --debug                   : Enable Debug logging
    -i, --input-file              : Set path to a file with a list of Org/Repo,(true|false), one per line, to migrate keys
                                     true|false is for the deploy key READ_ONLY permissions.
    -dt, --destination-token      : Set Personal Access Token with repo scope to destination Organization
    -st, --source-token           : Set Personal Access Token with repo scope to original Organization
    -p, --repo-page-size          : Set the pagination size for the initial repository GraphQL query - defaults to 20
                                    If a timeout occurs, reduce this value
    
    -so, --source-org             : Name of the source GitHub Organization to be analyzed
    -do, --destination-org        : Name of the destination GitHub Organization to be updated

Description:
migrate-deploy-keys scans a source organization or input file for all repositories and gathers their deploy keys.
  It then migrates the deploy key of all repositories from the source Organization to the destination organization.

Example:
  gh migrate-deploy-keys --source-org OriginalOrg --destination-org MyNewOrg --source-token ABCDEFG1234567 --destination-token 1234567ABCDEFG

EOM
  exit 0
}
####################################
# Read in the parameters if passed #
####################################
PARAMS=""
while (( "$#" )); do
  case "$1" in
    -h|--help)
      PrintUsage;
      ;;
    -d|--debug)
      DEBUG=true
      shift
      ;;
    -dt|--destination-token)
      DESTINATION_TOKEN=$2
      shift 2
      ;;
    -st|--source-token)
      SOURCE_TOKEN=$2
      shift 2
      ;;
    -i|--input-file)
      INPUT_FILE_NAME=$2
      shift 2
      ;;
    -p|--repo-page-size)
      REPO_PAGE_SIZE=$2
      shift 2
      ;;
    -do|--destination-org)
      DESTINATION_ORG_NAME=$2
      shift 2
      ;;
    -so|--source-org)
      SOURCE_ORG_NAME=$2
      shift 2
      ;;
    --) # end argument parsing
      shift
      break
      ;;
    -*) # unsupported flags
      echo "Error: Unsupported flag $1" >&2
      exit 1
      ;;
    *) # preserve positional arguments
  PARAMS="$PARAMS $1"
  shift
  ;;
  esac
done

##################################################
# Set positional arguments in their proper place #
##################################################
eval set -- "$PARAMS"

############
# Defaults #
############
REPO_PAGE_SIZE="${REPO_PAGE_SIZE:-100}" # Default to 100 if not passed
SOURCE_END_CURSOR='null'                # Set to null, will be updated after call
DESTINATION_END_CURSOR='null'           # Set to null, will be updated after call
GITHUB_API_URL='https://api.github.com' # Set to default GitHub API URL
LOG_DIR="$(pwd)"   # Set to default log directory
EPOCH_TIME=$(date +%s)                  # Set to current epoch time
LOG_FILE="${LOG_DIR}/gh-migrate-deploy-keys-${EPOCH_TIME}.log" # Set to default log file name
SLEEP='300'                             # Number of seconds to sleep if out of API calls
SLEEP_RETRY_COUNT='15'                  # Number of times to try to sleep before giving up
SLEEP_COUNTER='0'                       # Counter of how many times we have gone to sleep
API_REMAINING_SOURCE=0                  # Number of API calls remaining
API_LIMIT_REMAINING_SOURCE=0            # Number of API calls remaining before we hit the limit
API_REMAINING_DESTINATION=0             # Number of API calls remaining
API_LIMIT_REMAINING_DESTINATION=0       # Number of API calls remaining before we hit the limit
###########
# GLOBALS #
###########
SOURCE_REPO_ARRAY=()      # Array of source repo names
DESTINATION_REPO_ARRAY=() # Array of destination repo names
UPDATE_ARRAY=()           # Array of repos to update
KEYS_CREATED_SUCCESS=0    # Number of keys created
KEYS_CREATED_FAILURE=0    # Number of keys created
KEYS_DELETED_SUCCESS=0    # Number of keys deleted
KEYS_DELETED_FAILURE=0    # Number of keys deleted
PARALLEL=0                # If we can run in parallel
MAX_PARALLEL=6            # Maximum number of parallel processes to run

################################################################################
############################ FUNCTIONS #########################################
################################################################################
################################################################################
################################################################################
#### Function DebugJQ ##########################################################
DebugJQ() {
  # If Debug is on, print it out...
  if [[ ${DEBUG} == true ]]; then
    echo "$1" | jq '.'
  fi
}
################################################################################
#### Function Debug ############################################################
Debug() {
  # If Debug is on, print it out...
  if [[ ${DEBUG} == true ]]; then
    echo "$1"
  fi
}
################################################################################
#### Function ValidateJQ #######################################################
ValidateJQ() {
  # Need to validate the machine has jq installed as we use it to do the parsing
  # of all the json returns from GitHub

  if ! jq --version &>/dev/null
  then
    echo "Failed to find jq in the path!"
    echo "If this is a Mac, run command: brew install jq"
    echo "If this is Debian, run command: sudo apt install jq"
    echo "If this is Centos, run command: yum install jq"
    echo "Once installed, please run this script again."
    exit 1
  fi
}
################################################################################
#### Function CheckAPILimitDestination #########################################
CheckAPILimitDestination() {
  ##############################################################
  # Check what is remaining, and if 0, we need to sleep it off #
  ##############################################################
  API_REMAINING_REQUEST=$(curl -s -X GET \
    --url "${GITHUB_API_URL}/rate_limit" \
    -H "Authorization: Bearer ${DESTINATION_TOKEN}")

  Debug "DEBUG --- API REMAINING DATA BLOCK:"
  DebugJQ "${API_REMAINING_REQUEST}"

  API_REMAINING_MESSAGE=$(echo "${API_REMAINING_REQUEST}" \
    | jq -r '.message' 2>&1)

  if [[ "${API_REMAINING_MESSAGE}" != "Rate limiting is not enabled." ]]; then
    API_REMAINING_DESTINATION=$(echo "${API_REMAINING_REQUEST}" \
      | jq -r '.resources.graphql.remaining' 2>&1);
  else
    API_REMAINING_DESTINATION=9999999999
  fi

  #######################
  # Load the error code #
  #######################
  ERROR_CODE=$?

  ##############################
  # Check the shell for errors #
  ##############################
  if [ "${ERROR_CODE}" -ne 0 ]; then
    echo  "ERROR! Failed to get valid response back from GitHub API!"
    echo "ERROR:[${API_REMAINING_DESTINATION}]"
    exit 1
  fi

  ##########################################
  # Check to see if we have API calls left #
  ##########################################
  if [[ "${API_REMAINING_DESTINATION}" -eq 0 ]]; then
    # Increment the sleep counter
    ((SLEEP_COUNTER++))
    # Warn the user
    echo "WARN! We have run out of GrahpQL calls and need to sleep!"
    echo "Sleeping for ${SLEEP} seconds before next check"
    # Check if we have slept enough
    if [ "${SLEEP_COUNTER}" -gt "${SLEEP_RETRY_COUNT}" ]; then
      # We have been doing this too long
      echo "ERROR! We have tried to wait for:[$SLEEP_RETRY_COUNT] attempts!"
      echo "ERROR! We only sleep for:[${SLEEP_COUNTER}] attempts!"
      echo "Bailing out!"
      exit 1
    else
      # Get some sleep...
      sleep "${SLEEP}"
    fi
  elif [[ "${API_REMAINING_DESTINATION}" == 9999999999 ]]; then
    echo "API rate limiting is not enabled."
    # Set API limit remaining to the value we have
    API_LIMIT_REMAINING_DESTINATION="${API_REMAINING_DESTINATION}"
  else
    echo "[${API_REMAINING_DESTINATION}] Destination API attempts remaining..."
    # Set API limit remaining to the value we have
    API_LIMIT_REMAINING_DESTINATION="${API_REMAINING_DESTINATION}"
  fi
}
################################################################################
#### Function CheckAPILimitSource ##############################################
CheckAPILimitSource() {
  ##############################################################
  # Check what is remaining, and if 0, we need to sleep it off #
  ##############################################################
  API_REMAINING_REQUEST=$(curl -s -X GET \
    --url "${GITHUB_API_URL}/rate_limit" \
    -H "Authorization: Bearer ${SOURCE_TOKEN}")

  Debug "DEBUG --- API REMAINING DATA BLOCK:"
  DebugJQ "${API_REMAINING_REQUEST}"

  API_REMAINING_MESSAGE=$(echo "${API_REMAINING_REQUEST}" \
    | jq -r '.message' 2>&1)

  if [[ "${API_REMAINING_MESSAGE}" != "Rate limiting is not enabled." ]]; then
    API_REMAINING_SOURCE=$(echo "${API_REMAINING_REQUEST}" \
      | jq -r '.resources.graphql.remaining' 2>&1);
  else
    API_REMAINING_SOURCE=9999999999
  fi

  #######################
  # Load the error code #
  #######################
  ERROR_CODE=$?

  ##############################
  # Check the shell for errors #
  ##############################
  if [ "${ERROR_CODE}" -ne 0 ]; then
    echo  "ERROR! Failed to get valid response back from GitHub API!"
    echo "ERROR:[${API_REMAINING_SOURCE}]"
    exit 1
  fi

  ##########################################
  # Check to see if we have API calls left #
  ##########################################
  if [[ "${API_REMAINING_SOURCE}" -eq 0 ]]; then
    # Increment the sleep counter
    ((SLEEP_COUNTER++))
    # Warn the user
    echo "WARN! We have run out of GrahpQL calls and need to sleep!"
    echo "Sleeping for ${SLEEP} seconds before next check"
    # Check if we have slept enough
    if [ "${SLEEP_COUNTER}" -gt "${SLEEP_RETRY_COUNT}" ]; then
      # We have been doing this too long
      echo "ERROR! We have tried to wait for:[$SLEEP_RETRY_COUNT] attempts!"
      echo "ERROR! We only sleep for:[${SLEEP_COUNTER}] attempts!"
      echo "Bailing out!"
      exit 1
    else
      # Get some sleep...
      sleep "${SLEEP}"
    fi
  elif [[ "${API_REMAINING_SOURCE}" == 9999999999 ]]; then
    echo "API rate limiting is not enabled."
    # Set API limit remaining to the value we have
    API_LIMIT_REMAINING_SOURCE="${API_REMAINING_SOURCE}"
  else
    echo "[${API_REMAINING_SOURCE}] Source API attempts remaining..."
    # Set API limit remaining to the value we have
    API_LIMIT_REMAINING_SOURCE="${API_REMAINING_SOURCE}"
  fi
}
################################################################################
#### Function Header ###########################################################
Header() {
  echo ""
  echo "######################################################"
  echo "######################################################"
  echo "########### GitHub Migrate Deploy keys ###############"
  echo "######################################################"
  echo "######################################################"
  echo ""
  echo "NOTE:"
  echo "This script is used by the gh command line to help migrate GitHub Deploy Keys"
  echo "In order to do this, it will need to remove the deploy key from the"
  echo "source organization repository and add it to the destination organization repository."
  echo "There is some level of risk associated with this script, so please use it with caution."
  echo ""
  echo "Logs will be written to:[${LOG_FILE}]"
  echo ""

  # Debug info
  Debug "---- DEBUG ----"
  Debug "Source Token:[${SOURCE_TOKEN}]"
  Debug "Destination Token:[${DESTINATION_TOKEN}]"
  Debug "Source Organization:[${SOURCE_ORG_NAME}]"
  Debug "Destination Organization:[${DESTINATION_ORG_NAME}]"
  Debug "Repo Page Size:[${REPO_PAGE_SIZE}]"
  Debug "Input File:[${INPUT_FILE_NAME}]"
  Debug "LOG_DIR:[${LOG_DIR}]"
  Debug "Log File:[${LOG_FILE}]"
  Debug "---- DEBUG ----"
}
################################################################################
#### Function Footer ###########################################################
Footer() {
  # Basic footer information and totals
  echo ""
  echo "######################################################"
  echo "The script has completed"
  echo "######################################################"
  echo "Total Deploy Keys Created Successfully:[${KEYS_CREATED_SUCCESS}]"
  echo "Total Deploy Keys Deleted Successfully:[${KEYS_DELETED_SUCCESS}]"
  echo ""
  echo "Total Deploy Keys Created that Failed:[${KEYS_CREATED_FAILURE}]"
  echo "Total Deploy Keys Deleted that Failed:[${KEYS_DELETED_FAILURE}]"
  echo ""
}
################################################################################
#### Function GetAllSourceRepos ################################################
GetAllSourceRepos() {
  echo "Getting all source repos for:[${SOURCE_ORG_NAME}]"
  Debug "SOURCE_END_CURSOR:[${SOURCE_END_CURSOR}]"

  # Need to quote the string if its not null
  SOURCE_END_CURSOR_STRING="${SOURCE_END_CURSOR}"
  if [[ "${SOURCE_END_CURSOR}" != "null" ]]; then
    SOURCE_END_CURSOR_STRING='\"'
    SOURCE_END_CURSOR_STRING+="${SOURCE_END_CURSOR}"
    SOURCE_END_CURSOR_STRING+='\"'
  fi
  # Need to quote the string
  SOURCE_ORG_NAME_STRING='\"'
  SOURCE_ORG_NAME_STRING+="${SOURCE_ORG_NAME}"
  SOURCE_ORG_NAME_STRING+='\"'

  # Get the data block from the GitHub API
  DATA_BLOCK=$(curl --fail -s -X POST \
    --url https://api.github.com/graphql \
    -H 'Accept: application/vnd.github.starfire-preview+json' \
    -H "Authorization: Bearer ${SOURCE_TOKEN}" \
    -H 'Content-Type: application/json' \
    -d "{\"query\":\"query {organization(login: ${SOURCE_ORG_NAME_STRING}) {repositories(first: ${REPO_PAGE_SIZE}, after: ${SOURCE_END_CURSOR_STRING}) {nodes {nameWithOwner deployKeys(first: 100, after: null) {totalCount nodes {id title key readOnly}}} totalCount pageInfo {hasNextPage endCursor}}}}\"}" 2>&1)

  # Load the error code
  ERROR_CODE=$?

  # Check the shell return
  if [ $ERROR_CODE -ne 0 ]; then
    echo "ERROR! Failed to gather data from GitHub!"
    exit 1
  fi

  # Get the next page and end cursor
  NEXT_PAGE=$(echo "$DATA_BLOCK" | jq .[] | jq -r '.organization.repositories.pageInfo.hasNextPage')
  SOURCE_END_CURSOR=$(echo "$DATA_BLOCK" | jq .[] | jq -r '.organization.repositories.pageInfo.endCursor')

  # Debug info
  Debug "DATA_BLOCK:[${DATA_BLOCK}]"
  Debug "NEXT_PAGE:[${NEXT_PAGE}]"
  Debug "SOURCE_END_CURSOR:[${SOURCE_END_CURSOR}]"

  # Parse all the repo data out of data block
  ParseSourceRepoData "$DATA_BLOCK"

  # See if we need to loop for more data
  if [ "$NEXT_PAGE" == "false" ]; then
    # We have all the data, we can move on
    echo "Gathered all data from source GitHub Organization"
    echo "----------------------------------------------------"
  elif [ "$NEXT_PAGE" == "true" ]; then
    # We need to loop through GitHub to get all repos
    echo "More pages of repos... Looping through data with new cursor:[$SOURCE_END_CURSOR]"
    # Call GetData again with new cursor
    GetAllSourceRepos
  else
    # Failing to get this value means we didnt get a good response back from GitHub
    # And it could be bad input from user, not enough access, or a bad token
    # Fail out and have user validate the info
    echo ""
    echo "######################################################"
    echo "ERROR! Failed response back from GitHub!"
    echo "Please validate your PAT, Organization, and access levels!"
    echo "######################################################"
    exit 1
  fi
}
################################################################################
#### Function ParseSourceRepoData ##############################################
ParseSourceRepoData() {
  # Pull in the repos data block
  PARSE_DATA=$1
  # Convert the format to JSON
  _jq() {
    echo -n "${PARSE_DATA}" | base64 --decode | jq -r "${1}"
  }

  REPOS=$(echo "${PARSE_DATA}" | jq -r '.data.organization.repositories.nodes')
  for REPO_DATA in $(echo -n "${REPOS}" | jq -r '.[] | @base64'); do
    _jq() {
    echo -n "${REPO_DATA}" | base64 --decode | jq -r "${1}"
    }
    # Build out the vars for the function
    ORG_REPO_NAME=$(_jq '.nameWithOwner')
    DEPLOY_KEYS_COUNT=$(_jq '.deployKeys.totalCount')
    # Debug info
    Debug "ORG_REPO_NAME:[${ORG_REPO_NAME}]"
    Debug "DEPLOY_KEYS_COUNT:[${DEPLOY_KEYS_COUNT}]"

    if [ "${DEPLOY_KEYS_COUNT}" -gt 0 ]; then
      # We have deploy keys, lets get them
      echo "Getting deploy keys for repo:[${ORG_REPO_NAME}]"
      KEYS=$(echo "${PARSE_DATA}" | jq -r '.data.organization.repositories.nodes[] | select(.nameWithOwner == "'"${ORG_REPO_NAME}"'") | .deployKeys.nodes')
      for KEY_DATA in $(echo -n "${KEYS}" | jq -r '.[] | @base64'); do
        _jq() {
        echo -n "${KEY_DATA}" | base64 --decode | jq -r "${1}"
        }
        # Build out the vars for the function
        KEY_ID=$(_jq '.id')
        KEY_TITLE=$(_jq '.title')
        KEY_VALUE=$(_jq '.key')
        KEY_READ_ONLY=$(_jq '.readOnly')
        # Debug info
        Debug "KEY_ID:[${KEY_ID}]"
        Debug "KEY_TITLE:[${KEY_TITLE}]"
        Debug "KEY_VALUE:[${KEY_VALUE}]"
        Debug "KEY_READ_ONLY:[${KEY_READ_ONLY}]"
        # Get the org repo name and make lowercase
        ORG_REPO=$(echo "${ORG_REPO_NAME}" | tr '[:upper:]' '[:lower:]')
        # Create string of all values to add to array
        KEY_STRING="${ORG_REPO}|${KEY_ID}|${KEY_TITLE}|${KEY_VALUE}|${KEY_READ_ONLY}"
        echo "Adding key:"
        echo " - ORG/REPO:[${ORG_REPO}]"
        echo " - KEY_ID:[${KEY_ID}]"
        echo " - KEY_TITLE:[${KEY_TITLE}]"
        echo " - KEY_VALUE:[${KEY_VALUE}]"
        echo " - KEY_READ_ONLY:[${KEY_READ_ONLY}]"
        # Add the key to the source repo array
        SOURCE_REPO_ARRAY+=("${KEY_STRING}")
      done
    fi
  done
}
################################################################################
#### Function GetAllDestinationRepos ###########################################
GetAllDestinationRepos() {
  echo "Getting all destination repos for:[${DESTINATION_ORG_NAME}]"
  Debug "DESTINATION_END_CURSOR:[${DESTINATION_END_CURSOR}]"

  # Need to quote the string if its not null
  DESTINATION_END_CURSOR_STRING="${DESTINATION_END_CURSOR}"
  if [[ "${DESTINATION_END_CURSOR}" != "null" ]]; then
    DESTINATION_END_CURSOR_STRING='\"'
    DESTINATION_END_CURSOR_STRING+="${DESTINATION_END_CURSOR}"
    DESTINATION_END_CURSOR_STRING+='\"'
  fi
  # Need to quote the string
  DESTINATION_ORG_NAME_STRING='\"'
  DESTINATION_ORG_NAME_STRING+="${DESTINATION_ORG_NAME}"
  DESTINATION_ORG_NAME_STRING+='\"'

  # Get the data block from the GitHub API
  DATA_BLOCK=$(curl --fail -s -X POST \
    --url https://api.github.com/graphql \
    -H 'Accept: application/vnd.github.starfire-preview+json' \
    -H "Authorization: Bearer ${DESTINATION_TOKEN}" \
    -H 'Content-Type: application/json' \
    -d "{\"query\":\"query {organization(login: ${DESTINATION_ORG_NAME_STRING}) {repositories(first: ${REPO_PAGE_SIZE}, after: ${DESTINATION_END_CURSOR_STRING}) {nodes {nameWithOwner deployKeys(first: 100, after: null) {totalCount nodes {id title key readOnly}}} totalCount pageInfo {hasNextPage endCursor}}}}\"}" 2>&1)

  # Load the error code
  ERROR_CODE=$?

  # Check the shell return
  if [ $ERROR_CODE -ne 0 ]; then
    echo "ERROR! Failed to gather data from GitHub!"
    exit 1
  fi

  # Get the next page and end cursor
  NEXT_PAGE=$(echo "$DATA_BLOCK" | jq .[] | jq -r '.organization.repositories.pageInfo.hasNextPage')
  DESTINATION_END_CURSOR=$(echo "$DATA_BLOCK" | jq .[] | jq -r '.organization.repositories.pageInfo.endCursor')

  # Debug info
  Debug "DATA_BLOCK:[${DATA_BLOCK}]"
  Debug "NEXT_PAGE:[${NEXT_PAGE}]"
  Debug "DESTINATION_END_CURSOR:[${DESTINATION_END_CURSOR}]"

  # Parse all the repo data out of data block
  ParseDestinationRepoData "$DATA_BLOCK"

  # See if we need to loop for more data
  if [ "$NEXT_PAGE" == "false" ]; then
    # We have all the data, we can move on
    echo "Gathered all data from destination GitHub Organization"
    echo "----------------------------------------------------"
  elif [ "$NEXT_PAGE" == "true" ]; then
    # We need to loop through GitHub to get all repos
    echo "More pages of repos... Looping through data with new cursor:[${DESTINATION_END_CURSOR}]"
    # Call GetData again with new cursor
    GetAllDestinationRepos
  else
    # Failing to get this value means we didnt get a good response back from GitHub
    # And it could be bad input from user, not enough access, or a bad token
    # Fail out and have user validate the info
    echo ""
    echo "######################################################"
    echo "ERROR! Failed response back from GitHub!"
    echo "Please validate your PAT, Organization, and access levels!"
    echo "######################################################"
    exit 1
  fi
}
################################################################################
#### Function ParseDestinationRepoData #########################################
ParseDestinationRepoData() {
  # Pull in the repos data block
  PARSE_DATA=$1
  # Convert the format to JSON
  _jq() {
    echo -n "${PARSE_DATA}" | base64 --decode | jq -r "${1}"
  }

  REPOS=$(echo "${PARSE_DATA}" | jq -r '.data.organization.repositories.nodes')
  for REPO_DATA in $(echo -n "${REPOS}" | jq -r '.[] | @base64'); do
    _jq() {
    echo -n "${REPO_DATA}" | base64 --decode | jq -r "${1}"
    }
    # Build out the vars for the function
    ORG_REPO_NAME=$(_jq '.nameWithOwner')
    DEPLOY_KEYS_COUNT=$(_jq '.deployKeys.totalCount')
    # Debug info
    Debug "ORG_REPO_NAME:[${ORG_REPO_NAME}]"
    Debug "DEPLOY_KEYS_COUNT:[${DEPLOY_KEYS_COUNT}]"

    if [ "${DEPLOY_KEYS_COUNT}" -gt 0 ]; then
      # We have deploy keys, lets get them
      echo "Getting deploy keys for repo:[${ORG_REPO_NAME}]"
      KEYS=$(echo "${PARSE_DATA}" | jq -r '.data.organization.repositories.nodes[] | select(.nameWithOwner == "'"${ORG_REPO_NAME}"'") | .deployKeys.nodes')
      for KEY_DATA in $(echo -n "${KEYS}" | jq -r '.[] | @base64'); do
        _jq() {
        echo -n "${KEY_DATA}" | base64 --decode | jq -r "${1}"
        }
        # Build out the vars for the function
        KEY_ID=$(_jq '.id')
        KEY_TITLE=$(_jq '.title')
        KEY_VALUE=$(_jq '.key')
        KEY_READ_ONLY=$(_jq '.readOnly')
        # Debug info
        Debug "KEY_ID:[${KEY_ID}]"
        Debug "KEY_TITLE:[${KEY_TITLE}]"
        Debug "KEY_VALUE:[${KEY_VALUE}]"
        Debug "KEY_READ_ONLY:[${KEY_READ_ONLY}]"
        # Get the org repo name and make lowercase
        ORG_REPO=$(echo "${ORG_REPO_NAME}" | tr '[:upper:]' '[:lower:]')
        # Create string of all values to add to array
        KEY_STRING="${ORG_REPO}|${KEY_ID}|${KEY_TITLE}|${KEY_VALUE}|${KEY_READ_ONLY}"
        echo "Adding key:[${KEY_STRING}] to source array"
        # Add the key to the destination repo array
        DESTINATION_REPO_ARRAY+=("${KEY_STRING}")
      done
    else
      # Get the org repo name and make lowercase
      ORG_REPO=$(echo "${ORG_REPO_NAME}" | tr '[:upper:]' '[:lower:]')
      # create the string
      KEY_STRING="${ORG_REPO}|N/A|N/A|N/A|N/A"
      # Add the key to the destination repo array
       DESTINATION_REPO_ARRAY+=("${KEY_STRING}")
    fi
  done
}
################################################################################
#### Function ValidateArgs #####################################################
ValidateArgs() {
  # Check if user has provided the required arguments
  echo "----------------------------------------------------"
  echo "Validating user input..."
  
  # Make lower case to prevent weird issues
  DESTINATION_ORG_NAME=$(echo "${DESTINATION_ORG_NAME}" | tr '[:upper:]' '[:lower:]')
  SOURCE_ORG_NAME=$(echo "${SOURCE_ORG_NAME}" | tr '[:upper:]' '[:lower:]')

  # Check if user has passed input file
  if [ -n "${INPUT_FILE_NAME}" ] || [ "${#INPUT_FILE_NAME}" -lt 1 ] \
  && [ -z "${SOURCE_ORG_NAME}" ] && [ -z "${DESTINATION_ORG_NAME}" ] \
  && [ -z "${DESTINATION_TOKEN}" ]; then
    # user did not pass destination token, fail out
    echo "ERROR! You must provide a destination token to update the Destination Organization!"
    exit 1
  fi

  # Check we have all other vars if no input file
  if [ -z "${INPUT_FILE_NAME}" ]; then
    # We need both source and org vars
    if [ -z "${SOURCE_ORG_NAME}" ] || [ -z "${SOURCE_TOKEN}" ] || [ -z "${DESTINATION_ORG_NAME}" ] || [ -z "${DESTINATION_TOKEN}" ]; then
      echo "ERROR! You must provide [--destination-token] [--source-token] [--destination-org] [--source-org] to query and update!"
      exit 1
    fi
  fi

  # Validation successful, move on
  echo "Validation of input successful"
  echo "----------------------------------------------------"
}
################################################################################
#### Function GenerateUpdateList ###############################################
GenerateUpdateList() {
  echo "----------------------------------------------------"
  echo "Parsing all data and generating migration list..."
  # We now have all the data we need to generate the update list
  # SOURCE_REPO_ARRAY=()      # Array of source repo names
  # DESTINATION_REPO_ARRAY=() # Array of destination repo names
  # UPDATE_REPO_ARRAY=()      # Array of repo names to update
  #
  # String format per item is:
  # ORG_NAME/REPO_NAME|KEY_ID|KEY_TITLE|KEY_VALUE|KEY_READ_ONLY

  # Loop through the source repos and see if we have a match
  for SOURCE_OBJECT in "${SOURCE_REPO_ARRAY[@]}"; do
    KEY_EXISTS=0
    REPO_EXISTS=0
    # Split the repo name and visibility
    SOURCE_REPO_STRING=$(echo "${SOURCE_OBJECT}" | cut -d'|' -f1)
    SOURCE_ORG=$(echo "${SOURCE_REPO_STRING}" | cut -d'/' -f1)
    SOURCE_REPO=$(echo "${SOURCE_REPO_STRING}" | cut -d'/' -f2)
    SOURCE_KEY_ID=$(echo "${SOURCE_OBJECT}" | cut -d'|' -f2)
    SOURCE_KEY_TITLE=$(echo "${SOURCE_OBJECT}" | cut -d'|' -f3)
    SOURCE_KEY_VALUE=$(echo "${SOURCE_OBJECT}" | cut -d'|' -f4)
    SOURCE_KEY_READ_ONLY=$(echo "${SOURCE_OBJECT}" | cut -d'|' -f5)
    # Debug Info
    Debug "SOURCE_OBJECT:[${SOURCE_OBJECT}]"
    Debug "SOURCE_REPO_STRING:[${SOURCE_REPO_STRING}]"
    Debug "SOURCE_ORG:[${SOURCE_ORG}]"
    Debug "SOURCE_REPO:[${SOURCE_REPO}]"
    Debug "SOURCE_KEY_ID:[${SOURCE_KEY_ID}]"
    Debug "SOURCE_KEY_TITLE:[${SOURCE_KEY_TITLE}]"
    Debug "SOURCE_KEY_VALUE:[${SOURCE_KEY_VALUE}]"
    Debug "SOURCE_KEY_READ_ONLY:[${SOURCE_KEY_READ_ONLY}]"

    # Loop through the destination repos and see if we have a match in the source repos
    for DESTINATION_OBJECT in "${DESTINATION_REPO_ARRAY[@]}"; do
      # Split the repo name and visibility
      DESTINATION_REPO_STRING=$(echo "${DESTINATION_OBJECT}" | cut -d'|' -f1)
      DESTINATION_ORG=$(echo "${DESTINATION_REPO_STRING}" | cut -d'/' -f1)
      DESTINATION_REPO=$(echo "${DESTINATION_REPO_STRING}" | cut -d'/' -f2)
      DESTINATION_KEY_ID=$(echo "${DESTINATION_OBJECT}" | cut -d'|' -f2)
      DESTINATION_KEY_TITLE=$(echo "${DESTINATION_OBJECT}" | cut -d'|' -f3)
      DESTINATION_KEY_VALUE=$(echo "${DESTINATION_OBJECT}" | cut -d'|' -f4)
      DESTINATION_KEY_READ_ONLY=$(echo "${DESTINATION_OBJECT}" | cut -d'|' -f5)
      # Debug Info
      Debug "DESTINATION_OBJECT:[${DESTINATION_OBJECT}]"
      Debug "DESTINATION_REPO_STRING:[${DESTINATION_REPO_STRING}]"
      Debug "DESTINATION_ORG:[${DESTINATION_ORG}]"
      Debug "DESTINATION_REPO:[${DESTINATION_REPO}]"
      Debug "DESTINATION_KEY_ID:[${DESTINATION_KEY_ID}]"
      Debug "DESTINATION_KEY_TITLE:[${DESTINATION_KEY_TITLE}]"
      Debug "DESTINATION_KEY_VALUE:[${DESTINATION_KEY_VALUE}]"
      Debug "DESTINATION_KEY_READ_ONLY:[${DESTINATION_KEY_READ_ONLY}]"

      if [ "${SOURCE_REPO}" == "${DESTINATION_REPO}" ]; then
        # We found the repo, need to make note of it
        Debug "Found repo match:[${SOURCE_REPO}]"
        REPO_EXISTS=1
      fi
    
      # Check if the repo names match and if the key titles match and if the key values match
      if [ "${SOURCE_REPO}" == "${DESTINATION_REPO}" ] && [ "${SOURCE_KEY_TITLE}" == "${DESTINATION_KEY_TITLE}" ] && [ "${SOURCE_KEY_VALUE}" == "${DESTINATION_KEY_VALUE}" ]; then
        # We have a match,no need to the update list
        echo "----------------------------------------------------"
        echo "We have a match! Key:[${SOURCE_REPO_STRING}][${SOURCE_KEY_TITLE}] exists at:[${DESTINATION_REPO_STRING}][${DESTINATION_KEY_TITLE}]"
        Debug "Found the key on the new repo, no need to update"
        KEY_EXISTS=1
      fi

      # check if we have a match in the source repos
      if [ "${REPO_EXISTS}" -eq 1 ] && [ "${KEY_EXISTS}" -eq 0 ] && [ "${SOURCE_REPO}" == "${DESTINATION_REPO}" ]; then
        # We did not find the repo, add it to the update list
        echo "----------------------------------------------------"
        echo "We found matching repo:[${SOURCE_REPO_STRING}] but did not find matching key:[${SOURCE_KEY_TITLE}] at:[${DESTINATION_REPO_STRING}]"
        echo "Adding to update list"
        # Create string for UPDATE_ARRAY
        UPDATE_REPO_STRING="${SOURCE_ORG}/${SOURCE_REPO}|${SOURCE_KEY_TITLE}|${SOURCE_KEY_ID}|${DESTINATION_ORG}/${DESTINATION_REPO}|${SOURCE_KEY_VALUE}|${SOURCE_KEY_READ_ONLY}"
        # Add to the update array
        UPDATE_ARRAY+=("${UPDATE_REPO_STRING}")
      fi
    done
  done
}
################################################################################
#### Function DeleteKeyFromRepo ################################################
DeleteKeyFromRepo() {
  # Pull in input vars
  ORG_NAME="${1}"
  REPO_NAME="${2}"
  KEY_TITLE="${3}"
  KEY_ID="${4}"
  KEY_VALUE="${5}"

  # Check if we have api limit avilable
  if [ "${API_LIMIT_REMAINING_SOURCE}" -eq 0 ]; then
    # Call check api to wait for the limit to reset
    CheckAPILimitSource
  else
    echo "----------------------------------------------------"
    echo "Deleting key:[${KEY_TITLE}] from repo:[${REPO_NAME}]"

    # Write the information to the log file
    {
      echo "----------------------------------------------------"
      echo "Deleting key:[${KEY_TITLE}] from repo:[${ORG_NAME}/${REPO_NAME}] with title:[${KEY_TITLE}]"
      echo "KEY_ID:[${KEY_ID}]"
      echo "KEY_VALUE:[${KEY_VALUE}]"
    } >> "${LOG_FILE}"

    # Need to call the API to delete the github deploy key
    # https://developer.github.com/v3/repos/keys/#delete-a-deploy-key
    DELETE_CMD=$(curl --fail -s -X DELETE \
      --connect-timeout 5 \
      --max-time 10 \
      --retry 5 \
      --retry-delay 2 \
      --retry-max-time 40 \
      -H "Accept: application/vnd.github.v3+json" \
      -H "Authorization: token ${SOURCE_TOKEN}" \
      "${GITHUB_API_URL}/repos/${ORG_NAME}/${REPO_NAME}/keys/${KEY_ID}" 2>&1)

    # Check for errors
    ERROR_CODE=$?

    if [ "${ERROR_CODE}" -ne 0 ]; then
      echo "----------------------------------------------------"
      echo "Error deleting key:[${KEY_TITLE}] from repo:[${REPO_NAME}]"
      echo "Error Code:[${ERROR_CODE}]"
      echo "Error Message:[${DELETE_CMD}]"
      {
        echo "Failed to delete key"
        echo "Error Code:[${ERROR_CODE}]"
        echo "Error Message:[${DELETE_CMD}]"
        echo "----------------------------------------------------"
      } >> "${LOG_FILE}"
    else
      echo "----------------------------------------------------"
      echo "Successfully deleted key:[${KEY_TITLE}] from repo:[${REPO_NAME}]"
      # Decrement the API limit
      API_LIMIT_REMAINING_SOURCE=$((API_LIMIT_REMAINING_SOURCE-1))
      {
        echo "Successfully deleted key:[${KEY_TITLE}] from repo:[${REPO_NAME}]"
        echo "----------------------------------------------------"
      } >> "${LOG_FILE}"
    fi
  fi
}
#################################################################################
#### Function GetDeployKeysFromRepo #############################################
GetDeployKeysFromRepo() {
  # Pull in input vars
  ORG_NAME="${1}"
  REPO_NAME="${2}"

  # Get the deploy keys for the repo
  # https://developer.github.com/v3/repos/keys/#list-deploy-keys
  DEPLOY_KEYS=$(curl --fail -s -X GET \
    -H "Accept: application/vnd.github.v3+json" \
    -H "Authorization: token ${SOURCE_TOKEN}" \
    "${GITHUB_API_URL}/repos/${ORG_NAME}/${REPO_NAME}/keys" 2>&1)
  
  # Check for errors
  ERROR_CODE=$?

  if [ "${ERROR_CODE}" -ne 0 ]; then
    {
      echo "Failed to get deploy keys"
      echo "Error Code:[${ERROR_CODE}]"
      echo "Error Message:[${DEPLOY_KEYS}]"
      echo "----------------------------------------------------"
    } >> "${LOG_FILE}"
    exit 1
  else
    {
      echo "Successfully got deploy keys for repo:[${REPO_NAME}]"
      echo "----------------------------------------------------"
    } >> "${LOG_FILE}"
  fi

  # Parse the deploy keys
  mapfile -t KEYS < <(echo "${DEPLOY_KEYS}" | jq -r '.[] | .title + "|" + (.id|tostring) + "|" + .key')

  # Check if the array is empty
  if [ "${#KEYS[@]}" -eq 0 ]; then
    {
      echo "No deploy keys found for repo:[${REPO_NAME}]"
      echo "----------------------------------------------------"
    } >> "${LOG_FILE}"
  else
    {
      echo "Found ${#KEYS[*]} deploy keys for repo:[${REPO_NAME}]"
      echo "----------------------------------------------------"
    } >> "${LOG_FILE}"
  fi

  # return the array
  echo "${KEYS[@]}"
}
################################################################################
#### Function AddKeyToRepo #####################################################
AddKeyToRepo() {
  # Pull in vars
  ORG_NAME="${1}"
  REPO_NAME="${2}"
  KEY_TITLE="${3}"
  KEY_VALUE="${4}"
  KEY_READ_ONLY="${5}"

  echo "----------------------------------------------------"
  echo "Adding key:[${KEY_TITLE}] to repo:[${ORG_NAME}/${REPO_NAME}]"
  echo "KEY_VALUE:[${KEY_VALUE}]"
  echo "KEY_READ_ONLY:[${KEY_READ_ONLY}]"

  # Check if we have api limit avilable
  if [ "${API_LIMIT_REMAINING_DESTINATION}" -eq 0 ]; then
    # Call check api to wait for the limit to reset
    CheckAPILimitDestination
  else
    # Write the information to the log file
    {
      echo "----------------------------------------------------"
      echo "Creating key:[${KEY_TITLE}] from repo:[${REPO_NAME}] with title:[${KEY_TITLE}]"
      echo "KEY_VALUE:[${KEY_VALUE}]"
      echo "KEY_READ_ONLY:[${KEY_READ_ONLY}]"
    } >> "${LOG_FILE}"

    # Need to call the API to add the github deploy key
    # https://developer.github.com/v3/repos/keys/#add-a-deploy-key
    ADD_CMD=$(curl --fail -s -X POST \
      --connect-timeout 5 \
      --max-time 10 \
      --retry 5 \
      --retry-delay 2 \
      --retry-max-time 40 \
      -H "Accept: application/vnd.github.v3+json" \
      -H "Authorization: token ${DESTINATION_TOKEN}" \
      -H "Content-Type: application/json" \
      -d "{\"title\":\"${KEY_TITLE}\",\"key\":\"${KEY_VALUE}\",\"read_only\": ${KEY_READ_ONLY}}" \
      "${GITHUB_API_URL}/repos/${ORG_NAME}/${REPO_NAME}/keys" 2>&1)
    
    # Check for errors
    ERROR_CODE=$?

    if [ "${ERROR_CODE}" -ne 0 ]; then
      echo "----------------------------------------------------"
      echo "Error adding key:[${KEY_TITLE}] to repo:[${REPO_NAME}]"
      echo "Error Code:[${ERROR_CODE}]"
      echo "Error Message:[${ADD_CMD}]"
      {
        echo "Failed to add key"
        echo "Error Code:[${ERROR_CODE}]"
        echo "Error Message:[${ADD_CMD}]"
        echo "----------------------------------------------------"
      } >> "${LOG_FILE}"
    else
      echo "----------------------------------------------------"
      echo "Successfully added key:[${KEY_TITLE}] to repo:[${REPO_NAME}]"
      # Decrement the API limit
      API_LIMIT_REMAINING_DESTINATION=$((API_LIMIT_REMAINING_DESTINATION-1))
      {
        echo "Successfully added key:[${KEY_TITLE}] to repo:[${REPO_NAME}]"
        echo "----------------------------------------------------"
      } >> "${LOG_FILE}"
    fi
  fi
}
################################################################################
#### Function GetKeyID #########################################################
GetKeyID() {
  # Pull in vars
  ORG_NAME="${1}"
  REPO_NAME="${2}"
  KEY_TITLE="${3}"
  KEY_ID=""

  # Get the key ID
  # https://developer.github.com/v3/repos/keys/#get-a-specific-key
  GET_KEYS_CMD=$(curl --fail -s -X GET \
    --connect-timeout 5 \
    --max-time 10 \
    --retry 5 \
    --retry-delay 0 \
    --retry-max-time 40 \
    -H "Accept: application/vnd.github.v3+json" \
    -H "Authorization: token ${SOURCE_TOKEN}" \
    "${GITHUB_API_URL}/repos/${ORG_NAME}/${REPO_NAME}/keys" 2>&1)
  
  # Check for errors
  ERROR_CODE=$?

  if [ "${ERROR_CODE}" -ne 0 ]; then
    KEY_ID="FAILED"
  fi

  # Parse the key ID
  KEY_ID=$(echo "${GET_KEYS_CMD}" | jq -r '.[] | select(.title == "'"${KEY_TITLE}"'") | .id')

  # Decrement the API limit
  API_LIMIT_REMAINING_SOURCE=$((API_LIMIT_REMAINING_SOURCE-1))

  # Return the key ID
  echo "${KEY_ID}"
}
################################################################################
#### Function ReadInputFile ####################################################
ReadInputFile() {
  # Read in the input file and parse the lines
  while read -r LINE; do
    #############################################
    # Split the line into the org and repo name #
    #############################################
    REPO_NAME=$(echo "${LINE}" | tr '[:upper:]' '[:lower:]')

    # Debug info
    Debug "REPO_NAME:[${REPO_NAME}]"

    # Get the deploy keys with this repo
    Debug "Getting deploy keys for repo:[${SOURCE_ORG_NAME}/${REPO_NAME}]"

    # Create array of deploy keys returned from GetDeployKeysFromRepo
    mapfile -t KEYS_ARRAY < <(GetDeployKeysFromRepo "${SOURCE_ORG_NAME}" "${REPO_NAME}")

    # Check the api limit
    CheckAPILimitSource
    CheckAPILimitDestination

    # Check if the array is empty
    if [ "${#KEYS_ARRAY[@]}" -eq 0 ]; then
      echo "----------------------------------------------------"
      echo "No deploy keys found for repo:[${SOURCE_ORG_NAME}/${REPO_NAME}]"
      {
        echo "No deploy keys found for repo:[${SOURCE_ORG_NAME}/${REPO_NAME}]"
        echo "----------------------------------------------------"
      } >> "${LOG_FILE}"
      exit 2
    else
      # Count how many keys are in the array
      KEYS_COUNT="${#KEYS_ARRAY[@]}"
      # Check if more keys than api limit
      if [ "${KEYS_COUNT}" -gt "${API_LIMIT_REMAINING_DESTINATION}" ]; then
        echo "There are more keys:[${KEYS_COUNT}] than the API limit:[${API_LIMIT}]"
        echo "Please extend your API limit or create less keys"
        exit 1
      fi
      # Loop through the array and add the keys
      for KEY in "${KEYS_ARRAY[@]}"; do
        # Split the key into the title and value
        KEY_TITLE=$(echo "${KEY}" | cut -d'|' -f1)
        KEY_ID=$(echo "${KEY}" | cut -d'|' -f2)
        KEY_VALUE=$(echo "${KEY}" | cut -d'|' -f3)
       
        # Check if parallel is true
        if [ "${PARALLEL}" == "true" ]; then
          Debug "running in parallel"
          sem -j"${MAX_PARALLEL}" "./gh-migrate-deploy-keys-parallel.sh" "${SOURCE_ORG_NAME}" "${REPO_NAME}" "${SOURCE_TOKEN}" "${DESTINATION_ORG}" "${REPO_NAME}" "${DESTINATION_TOKEN}" "${KEY_TITLE}" "${KEY_ID}" "${KEY_VALUE}" "${LOG_FILE}" "${GITHUB_API_URL}"
        else
          Debug "Deleting key from source repo"
          DeleteKeyFromRepo "${SOURCE_ORG_NAME}" "${REPO_NAME}" "${KEY_TITLE}" "${KEY_ID}" "${KEY_VALUE}"

          # Add the key to the repo
          Debug "Adding key:[${KEY_TITLE}] to repo:[${SOURCE_ORG_NAME}/${REPO_NAME}]"
          AddKeyToRepo "${DESTINATION_ORG}" "${REPO_NAME}" "${KEY_TITLE}" "${KEY_VALUE}"
        fi
      done
      # Wait for all the jobs to finish
      if [ "${PARALLEL}" -eq 1 ]; then
        # Wait for all the jobs to finish
        sem --wait
      fi
    fi
  done < "${INPUT_FILE_NAME}"
}
################################################################################
#### Function ParseUpdateArray #################################################
ParseUpdateArray() {
  # Check the API limit
  CheckAPILimitSource
  CheckAPILimitDestination
  # Loop through the list of repos and update the visibility
  for OBJECT in "${UPDATE_ARRAY[@]}"; do
   # Create string for UPDATE_ARRAY
    # UPDATE_REPO_STRING="${SOURCE_ORG}/${SOURCE_REPO}|${SOURCE_KEY_TITLE}|${SOURCE_KEY_ID}|${DESTINATION_ORG}/${DESTINATION_REPO}|${DESTINATION_KEY_VALUE}"
    # Split the string into the org and repo name
    SOURCE_ORG=$(echo "${OBJECT}" | cut -d'|' -f1 | cut -d'/' -f1)
    SOURCE_REPO=$(echo "${OBJECT}" | cut -d'|' -f1 | cut -d'/' -f2)
    SOURCE_KEY_TITLE=$(echo "${OBJECT}" | cut -d'|' -f2)
    SOURCE_KEY_ID=$(echo "${OBJECT}" | cut -d'|' -f3)
    DESTINATION_ORG=$(echo "${OBJECT}" | cut -d'|' -f4 | cut -d'/' -f1)
    DESTINATION_REPO=$(echo "${OBJECT}" | cut -d'|' -f4 | cut -d'/' -f2)
    DESTINATION_KEY_VALUE=$(echo "${OBJECT}" | cut -d'|' -f5)
    SOURCE_KEY_READ_ONLY=$(echo "${OBJECT}" | cut -d'|' -f6)

    # The SOURCE_KEY_ID is the node ID and not the actual ID... 
    # This cannot be pulled from graphql and needs to be pulled from the API
    # Get the key ID from the API
    SOURCE_KEY_ID=$(GetKeyID "${SOURCE_ORG}" "${SOURCE_REPO}" "${SOURCE_KEY_TITLE}")

    # Check if the key ID is FAILED
    if [ "${SOURCE_KEY_ID}" == "FAILED" ]; then
      echo "----------------------------------------------------"
      echo "Failed to get key ID for key:[${SOURCE_KEY_TITLE}] from repo:[${SOURCE_ORG}/${SOURCE_REPO}]"
      echo "Failed to get key ID for key:[${SOURCE_KEY_TITLE}] from repo:[${SOURCE_ORG}/${SOURCE_REPO}]" >> "${LOG_FILE}"
      echo "----------------------------------------------------" >> "${LOG_FILE}"
      exit 2
    fi

    # Variables to pass to parallel script
    # SOURCE_ORG_NAME="${1}"
    # SOURCE_REPO_NAME="${2}"
    # SOURCE_TOKEN="${3}"
    # DESTINATION_ORG_NAME="${4}"
    # DESTINATION_REPO_NAME="${5}"
    # DESTINATION_TOKEN="${6}"
    # KEY_TITLE="${7}"
    # KEY_ID="${8}"
    # KEY_VALUE="${9}"
    # KEY_READ_ONLY="${10}"
    # LOG_FILE="${11}"
    # GITHUB_API_URL="${12}"

    # Check if parallel is true
    if [ "${PARALLEL}" == "true" ]; then
      Debug "running in parallel"
      # Run the parallel script
      sem -j"${MAX_PARALLEL}" "./gh-migrate-deploy-keys-parallel.sh" "${SOURCE_ORG}" "${SOURCE_REPO}" "${SOURCE_TOKEN}" "${DESTINATION_ORG}" "${DESTINATION_REPO}" "${DESTINATION_TOKEN}" "${SOURCE_KEY_TITLE}" "${SOURCE_KEY_ID}" "${DESTINATION_KEY_VALUE}" "${LOG_FILE}" "${GITHUB_API_URL}"
    else
      Debug "Deleting key from source repo"
      DeleteKeyFromRepo "${SOURCE_ORG}" "${SOURCE_REPO}" "${SOURCE_KEY_TITLE}" "${SOURCE_KEY_ID}" "${DESTINATION_KEY_VALUE}"

      # We need to add the key to the destination repo
      Debug "Adding key to destination repo"
      AddKeyToRepo "${DESTINATION_ORG}" "${DESTINATION_REPO}" "${SOURCE_KEY_TITLE}" "${DESTINATION_KEY_VALUE}" "${SOURCE_KEY_READ_ONLY}"
    fi
  done

  # Wait for all the jobs to finish
  if [ "${PARALLEL}" -eq 1 ]; then
    # Wait for all the jobs to finish
    sem --wait
  fi
}
################################################################################
#### Function UpdateKeyCounts ##################################################
UpdateKeyCounts() {
  # We need to parse the log file and get the number of keys added and deleted
  # We also need to see if KEYS_CREATED_SUCCESS and KEYS_DELETED_SUCCESS are set and accurate
  # Failed to delete key
  # Successfully deleted key
  #
  # Failed to add key
  # Successfully added key

  # Check if the log file exists
  if [ -f "${LOG_FILE}" ]; then
    # Get the number of keys added
    KEYS_CREATED_SUCCESS=$(grep -c "Successfully added key" "${LOG_FILE}")
    # Get the number of keys added with failures
    KEYS_CREATED_FAILURE=$(grep -c "Failed to add key" "${LOG_FILE}")
    # Get the number of keys deleted
    KEYS_DELETED_SUCCESS=$(grep -c "Successfully deleted key" "${LOG_FILE}")
    # Get the number of keys deleted with failures
    KEYS_DELETED_FAILURE=$(grep -c "Failed to delete key" "${LOG_FILE}")
  else
    # Failed to find log!
    echo "Failed to find log file:[${LOG_FILE}]"
    exit 1
  fi
}
################################################################################
#### Function ValidateSem ######################################################
ValidateSem() {
  # Need to validate the machine has sem installed as we use it to do the
  #  actual work.
  if ! sem --version &>/dev/null
  then
    echo "Failed to find GNU sem in the path!"
    echo "https://www.gnu.org/software/parallel/"
    echo "This can be used to parallel the calls to the GitHub API."
    echo "without sem, we will have to do it serially."
  else
    PARALLEL=1
    # Create the file to run the parallel calls
    CreateParallelFile
  fi
}
################################################################################
#### Function CreateParallelFile ###############################################
CreateParallelFile() {
  # Create the file to run the parallel calls
  cat >"gh-migrate-deploy-keys-parallel.sh" <<EOL
#!/bin/bash
 
SOURCE_ORG_NAME="\${1}"
SOURCE_REPO_NAME="\${2}"
SOURCE_TOKEN="\${3}"
DESTINATION_ORG_NAME="\${4}"
DESTINATION_REPO_NAME="\${5}"
DESTINATION_TOKEN="\${6}"
KEY_TITLE="\${7}"
KEY_ID="\${8}"
KEY_VALUE="\${9}"
KEY_READ_ONLY="\${10}"
LOG_FILE="\${11}"
GITHUB_API_URL="\${12}"

################################################################################
######################### FUNCTIONS BELOW ######################################
################################################################################
################################################################################
#### Function DeleteKeyFromRepo ################################################
DeleteKeyFromRepo() {
  # Pull in input vars
  ORG_NAME="\${1}"
  REPO_NAME="\${2}"
  KEY_TITLE="\${3}"
  KEY_ID="\${4}"
  KEY_VALUE="\${5}"

  echo "----------------------------------------------------"
  echo "Deleting key:[\${KEY_TITLE}] from repo:[\${REPO_NAME}]"

  # Write the information to the log file
  {
    echo "----------------------------------------------------"
    echo "Deleting key:[\${KEY_TITLE}] from repo:[\${ORG_NAME}/\${REPO_NAME}] with title:[\${KEY_TITLE}]"
    echo "KEY_ID:[\${KEY_ID}]"
    echo "KEY_VALUE:[\${KEY_VALUE}]"
  } >> "\${LOG_FILE}"

  # Need to call the API to delete the github deploy key
  # https://developer.github.com/v3/repos/keys/#delete-a-deploy-key
  DELETE_CMD=$(curl --fail -k -s -X DELETE \
    --connect-timeout 5 \
    --max-time 10 \
    --retry 5 \
    --retry-delay 2 \
    --retry-max-time 40 \
    -H "Accept: application/vnd.github.v3+json" \
    -H "Authorization: token \${SOURCE_TOKEN}" \
    "\${GITHUB_API_URL}/repos/\${ORG_NAME}/\${REPO_NAME}/keys/\${KEY_ID}" 2>&1)

  # Check for errors
  ERROR_CODE=\$?

  if [ "\${ERROR_CODE}" -ne 0 ]; then
    echo "----------------------------------------------------"
    echo "Error deleting key:[\${KEY_TITLE}] from repo:[\${REPO_NAME}]"
    echo "Error Code:[\${ERROR_CODE}]"
    echo "Error Message:[\${DELETE_CMD}]"
    {
      echo "Failed to delete key"
      echo "Error Code:[\${ERROR_CODE}]"
      echo "Error Message:[\${DELETE_CMD}]"
      echo "----------------------------------------------------"
    } >> "\${LOG_FILE}"
  else
    echo "----------------------------------------------------"
    echo "Successfully deleted key:[\${KEY_TITLE}] from repo:[\${REPO_NAME}]"
    {
      echo "Successfully deleted key:[\${KEY_TITLE}] from repo:[\${REPO_NAME}]"
      echo "----------------------------------------------------"
    } >> "\${LOG_FILE}"
  fi
}
################################################################################
#### Function AddKeyToRepo #####################################################
AddKeyToRepo() {
  # Pull in vars
  ORG_NAME="\${1}"
  REPO_NAME="\${2}"
  KEY_TITLE="\${3}"
  KEY_VALUE="\${4}"
  KEY_READ_ONLY="\${5}"

  echo "----------------------------------------------------"
  echo "Adding key:[\${KEY_TITLE}] to repo:[\${ORG_NAME}/\${REPO_NAME}]"
  echo "KEY_VALUE:[\${KEY_VALUE}]"
  echo "KEY_READ_ONLY:[\${KEY_READ_ONLY}]"

  # Write the information to the log file
  {
    echo "----------------------------------------------------"
    echo "Creating key:[\${KEY_TITLE}] from repo:[\${REPO_NAME}] with title:[\${KEY_TITLE}]"
    echo "KEY_VALUE:[\${KEY_VALUE}]"
    echo "KEY_READ_ONLY:[\${KEY_READ_ONLY}]"
  } >> "\${LOG_FILE}"

  # Need to call the API to add the github deploy key
  # https://developer.github.com/v3/repos/keys/#add-a-deploy-key
  ADD_CMD=$(curl --fail -k -s -X POST \
    --connect-timeout 5 \
    --max-time 10 \
    --retry 5 \
    --retry-delay 2 \
    --retry-max-time 40 \
    -H "Accept: application/vnd.github.v3+json" \
    -H "Authorization: token \${DESTINATION_TOKEN}" \
    -H "Content-Type: application/json" \
    -d "{\"title\":\"\${KEY_TITLE}\",\"key\":\"\${KEY_VALUE}\",\"read_only\": \${KEY_READ_ONLY}}" \
    "\${GITHUB_API_URL}/repos/\${ORG_NAME}/\${REPO_NAME}/keys" 2>&1)
  
  # Check for errors
  ERROR_CODE=\$?

  if [ "\${ERROR_CODE}" -ne 0 ]; then
    echo "----------------------------------------------------"
    echo "Error adding key:[\${KEY_TITLE}] to repo:[\${REPO_NAME}]"
    echo "Error Code:[\${ERROR_CODE}]"
    echo "Error Message:[\${ADD_CMD}]"
    {
      echo "Failed to add key"
      echo "Error Code:[\${ERROR_CODE}]"
      echo "Error Message:[\${ADD_CMD}]"
      echo "----------------------------------------------------"
    } >> "\${LOG_FILE}"
  else
    echo "----------------------------------------------------"
    echo "Successfully added key:[\${KEY_TITLE}] to repo:[\${REPO_NAME}]"
    {
      echo "Successfully added key:[\${KEY_TITLE}] to repo:[\${REPO_NAME}]"
      echo "----------------------------------------------------"
    } >> "\${LOG_FILE}"
  fi
}
################################################################################
################################ MAIN ##########################################
################################################################################

# Delete the key from the source repo
DeleteKeyFromRepo "\${SOURCE_ORG_NAME}" "\${SOURCE_REPO_NAME}" "\${KEY_TITLE}" "\${KEY_ID}" "\${KEY_VALUE}"

# Add the key to the destination repo
AddKeyToRepo "\${DESTINATION_ORG_NAME}" "\${DESTINATION_REPO_NAME}" "\${KEY_TITLE}" "\${KEY_VALUE}" "\${KEY_READ_ONLY}"
EOL

  # Make the file executable
  chmod +x "gh-migrate-deploy-keys-parallel.sh"
}
################################################################################
############################## MAIN ############################################
################################################################################

##########
# Header #
##########
Header

#####################################
# Validate we have enough arguments #
#####################################
ValidateArgs

#########################
# Validate JQ installed #
#########################
ValidateJQ

#############################################
# Validate if sem is installed for parallel #
#############################################
ValidateSem

#####################################
# Check if were using an input file #
#####################################
if [[ -n "${INPUT_FILE_NAME}" ]]; then
  ################################
  # Read the input file for data #
  ################################
  ReadInputFile
else
  ###############################################
  # Get the list of all repos in the source org #
  ###############################################
  GetAllSourceRepos

  ####################################################
  # Get the list of all repos in the destination org #
  ####################################################
  GetAllDestinationRepos

  ###############################################################
  # Loop through the repos and generate list of repos to update #
  ###############################################################
  GenerateUpdateList

  ###############################################
  # Parse the update array and update the repos #
  ###############################################
  ParseUpdateArray
fi

#########################
# Update the key counts #
#########################
UpdateKeyCounts

##########
# Footer #
##########
Footer
